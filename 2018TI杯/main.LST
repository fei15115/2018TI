C51 COMPILER V9.54   MAIN                                                                  04/11/2021 15:34:12 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\keil5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\应用) DEBUG OBJECTEXTEND TA
                    -BS(2)

line level    source

   1          //-----------------------------------------------
   2          // 版权归    SivaYao   所有
   3          // 第一次编程时间:2018年07月20日
   4          //-----------------------------------------------
   5          // 文件名：  MAIN.C
   6          // 编写人：  Han(copy from SivaYao) 
   7          // 编写时间：2021/04/09
   8          // 目标器件: STC8H
   9          // 编译工具: Keil uV5
  10          //-----------------------------------------------
  11          // 程序说明:
  12          // 该程序基于FFT以及正弦波检测逻辑；实现可以检测插在电路板上的电器的作用。
  13          //-----------------------------------------------
  14          #include   "STC8A8K.h"   //芯片STC8A8K内部寄存器说明头文件
  15          #include   "HD7279.h"    //HD7279按键显示驱动库 头文件
  16          #include   "STC_HW.H"   //芯片 片上硬件驱动 头文件
*** WARNING C317 IN LINE 32 OF .\应用\STC_HW.H: attempt to redefine macro 'SYSTEM_OSC'
  17          #include   "FFT.H"       //FFT计算库 头文件
  18          #include   "LCD_ALI.h"
  19          #include   "math.h"
  20          #include   "Photo.h"
  21          //7323AD管脚定义
  22          u8 AD7323(u8 CMD);
  23          sbit SCK  = P4^3 ;
  24          sbit MOSI = P4^0 ;
  25          sbit MISO = P4^1 ;
  26          sbit ADCS = P5^1;// //T1
  27          sbit OUT0 = P6^2;//用来检测测量周期
  28          
  29          void   InterFace(void) ;
  30          extern int xdata Fft_Real[1024];
  31          extern int xdata Fft_Image[1024];               // fft的虚部
  32          extern code unsigned int LIST_TAB[1024];
  33          //unsigned int IRms[1024];
  34          
  35          //变量定义
  36          u8  Mode = 0 ;//三种测量模式,1--直接测量,2--FFT低频测量,2--FFT高频测量
  37          bit KeyFlag,T0Flag,MesOver,OneSec,S1SendOver;
  38          u8  KeyNum,S1Num,DisNum; 
  39          u16 T0Count,T_Acc,F_Count,F_Acc;
  40          u16 DataMax,NumMax;
  41          u16 DataMax1;
  42          u8  S1Send[20];
  43          u16 XBF[20],XBV[20],XBNum; //谐波频率,谐波幅度,谐波计数
  44          int  ADRes=0,ADOld;    //AD7323采样结果
  45          bit  TongDao = 1 ;
  46          long int AD_Acc,V_Acc,VPP,VRMS,FRMS,ADMul;     
  47          extern u16 FColor,BColor;
  48          u8 count=0;
  49          u8 find_flag = 0;
  50          
  51          void Delay1ms()   //@33.000MHz
  52          {
  53   1        unsigned char i, j;
C51 COMPILER V9.54   MAIN                                                                  04/11/2021 15:34:12 PAGE 2   

  54   1      
  55   1        i = 33;
  56   1        j = 22;
  57   1        do
  58   1        {
  59   2          while (--j);
  60   2        } while (--i);
  61   1      }
  62          
  63          
  64          void GETSIN( void )
  65          {
  66   1        int i;
  67   1        for(i=0;i<1024;i++)
  68   1        {
  69   2          Fft_Real[LIST_TAB[i]] = (int)(1024*sin(3.1415926*2*i*50.1/512));
  70   2          Fft_Image[LIST_TAB[i]] = 0;
  71   2        }
  72   1      }
  73          
  74          void GETSQR( void )
  75          {
  76   1        int i;
  77   1        for(i=0;i<1024;i++)
  78   1        {
  79   2          if(i/256%2)
  80   2            Fft_Real[LIST_TAB[i]]=(int)(-512);
  81   2            //Fft_Real[LIST_TAB[i]]=0;    
  82   2          else
  83   2            Fft_Real[LIST_TAB[i]]=(int)(512);
  84   2        }
  85   1      }
  86          
  87          void SANJIAO( void )
  88          {
  89   1        int i;
  90   1        for(i=0;i<1024;i++)
  91   1        {
  92   2          if(i<512)
  93   2            Fft_Real[LIST_TAB[i]]=(int)(-512+i*2);  
  94   2          else
  95   2            Fft_Real[LIST_TAB[i]]=(int)(1536-(i*2));
  96   2        }
  97   1      }
  98          
  99            u16 X  ,Y  ;
 100          void main()
 101          {
 102   1        long int VPP1,vrms1;
 103   1        int i;
 104   1      //0---仿真测试程序,现在不用
 105   1        GETSIN();
 106   1      //  GETSQR();
 107   1      //  SANJIAO();
 108   1        FFT();
 109   1        for ( i=0 ; i<512 ; i++ ) {
 110   2          Fft_Real[i] = sqrt((long int)Fft_Real[i]*Fft_Real[i]+(long int)Fft_Image[i]*Fft_Image[i]);
 111   2         }
 112   1      //1---硬件初始化程序,把片上硬件初始化(端口,定时器,SPI,串口,中断等)
 113   1        SystemInit();   
 114   1      //2---HD7279按键显示的初始化和测试显示(显示01234567)
 115   1        SEND7279_CMD(0xA4) ;
C51 COMPILER V9.54   MAIN                                                                  04/11/2021 15:34:12 PAGE 3   

 116   1        for (i=0;i<8;i++) 
 117   1        {
 118   2            SEND7279_CMD_DATA(0x80+i , 0);    
 119   2        }
 120   1        AD7323(0xA000);
 121   1        AD7323(0x8430);
 122   1        while(1){
 123   2          //1-----------------//如果一次测量完成
 124   2          if ( MesOver ) {   
 125   3            MesOver = 0 ;    //清除标志位
 126   3            //(1)如果是直接测量模式(正弦波测量)
 127   3           //(3)如果是FFT高频模式,采样频率2.56KHz,进行1024点FFT变换
 128   3           //转换完成后频率间隔点是2.5Hz,扫描把所有幅值超过阈值的频率点和幅值显示出来
 129   3              if ( Mode ==3 )   
 130   3             { //(3)如果是FFT高频模式
 131   4              FFT(  );       //(3.1)采集结果放在Fft_Real数组中,进行1024点FFT变换
 132   4              //XBNum = 0 ;
 133   4              //(3.2)变换完成后,整合各频率点实部和虚部,计算幅值,幅值也放在Fft_Real数组中
 134   4              for ( i= 1 ; i<401 ; i++ ) 
 135   4              {
 136   5                 Fft_Real[i] = sqrt((long int)Fft_Real[i]*Fft_Real[i]+(long int)Fft_Image[i]*Fft_Image[i]);          
 137   5                    }
 138   4              if((u32)Fft_Real[20]/10*625/128 > 0x50)
 139   4              {
 140   5                SEND7279_CMD(0xA4);
 141   5                SEND7279_CMD_DATA(0x87 , 1);
 142   5                find_flag = 1;
 143   5              }else{
 144   5                for(i=23 ; i<400 ;i++ )
 145   5                {
 146   6                  if(Fft_Real[i]*625/128/24*1414/100 > 10)
 147   6                  {
 148   7                    SEND7279_CMD(0xA4);
 149   7                    SEND7279_CMD_DATA(0x87 , 2);
 150   7                    find_flag = 1;
 151   7                  }
 152   6                }
 153   5                if(find_flag == 0)
 154   5                {
 155   6                  SEND7279_CMD(0xA4);
 156   6                  SEND7279_CMD_DATA(0x87 , 3);
 157   6                }
 158   5              }
 159   4              for ( i=0 ; i<400 ;i++ ) {   //串口数据输出程序,调试用
 160   5                  S1Send[0]= 0xaa ;
 161   5                S1Send[1]= 0xaa;
 162   5                S1Send[2]= i/256;
 163   5                S1Send[3]= i   ;
 164   5                S1Send[4]= (u32)Fft_Real[i]*625/1280>>8;
 165   5                S1Send[5]= (u32)Fft_Real[i]*625/1280;         
 166   5                S1Num = 0 ;SBUF = S1Send[0];
 167   5                S1SendOver = 0 ;          
 168   5                while ( S1SendOver == 0 ) {;}
 169   5                }
 170   4              //(3.3)显示字符串
 171   4              // GUI_ShowStr (12,108,16,"fn(Hz)",0);
 172   4              // GUI_ShowStr (12,124,16,"IP(0.1mA)",0);
 173   4              // //(3.4)设定初始坐标
 174   4              // X =60;Y =108;
 175   4                  //(3.5)扫描整个数组,输出幅值超过阈值(暂时取60)的频率点和幅值                  
 176   4               }  //end of Mode==3
 177   3            }  //end of MesOver==1
C51 COMPILER V9.54   MAIN                                                                  04/11/2021 15:34:12 PAGE 4   

 178   2      //2-----如果有按键按下----------------------
 179   2          if ( KeyFlag ) 
 180   2          {
 181   3            count++;
 182   3            KeyFlag = 0 ;  //清除标志位
 183   3              KeyNum = READ7279_NUM( );
 184   3                GUI_ShowChar(40,20,0x0000,0xFFFF,KeyNum+0x30,16,0);
 185   3            
 186   3            SEND7279_CMD(0xA4) ;
 187   3            Delay1ms();
 188   3            SEND7279_CMD_DATA(0x80 , KeyNum/10);
 189   3            Delay1ms();
 190   3            SEND7279_CMD_DATA(0x81 , KeyNum%10);
 191   3            Delay1ms();
 192   3            SEND7279_CMD_DATA(0x82 , count/10);
 193   3            Delay1ms();
 194   3            SEND7279_CMD_DATA(0x83 , count%10);
 195   3            //(2.1)如果键值是1 ----设定模式为1
 196   3                if ( KeyNum == 1 ) 
 197   3            {
 198   4                  Mode = 1 ; //程序切换到直接测量模式(测量正弦波)
 199   4              TR0  = 0 ; //暂停定时器
 200   4              ADCS=0;
 201   4              AD7323(0X80);
 202   4              AD7323(0X30);
 203   4              ADCS=1;
 204   4              TongDao=0;
 205   4              GUI_FillRec(4,39,476,316,WHITE);  //界面修改
 206   4                  FColor = DARKBLUE ;
 207   4              DisP_Photo  (120,40,120+240-1,40+36-1,CeLiang[0],0);  //显示"(1)正弦波测量"
 208   4              DisP_Photo  (8,80,8+464-1,80+24-1,PinLv,0);          //显示"频率峰峰值有效值"
 209   4                  TH0    = (65536 - 33000000/4800) /256 ; //
 210   4                  TL0    = (65536 - 33000000/4800) %256 ; //设定定时器0初值(1秒4800次中断0.25ms)  
 211   4                  TR0     = 1 ; //启动定时器0
 212   4              T0Count = 0 ; //定时器0计数值清零       
 213   4                }  //KeyNum == 1
 214   3            if ( KeyNum == 2 ) 
 215   3            { 
 216   4              Mode = 2 ;   //程序切换到FFT低频模式(测量基波)
 217   4              TR0     = 0 ;
 218   4              ADCS=0;
 219   4              AD7323(0X80);
 220   4              AD7323(0X30);
 221   4              ADCS=1;
 222   4              TongDao=0;
 223   4              GUI_FillRec(4,39,476,316,WHITE);  //界面修改
 224   4              FColor = DARKBLUE ;
 225   4              DisP_Photo  (120,40,120+240-1,40+36-1,CeLiang[1],0);  //显示"(2)任意波测量"
 226   4              DisP_Photo  (8,80,8+376-1,80+24-1,JiBo[0],0);        //显示"基波频率  幅值"       
 227   4                  TH0    = (65536 - 33000000/512) /256 ;
 228   4                  TL0    = (65536 - 33000000/512) %256 ; //定时器0初值(1秒512次中断2ms) 
 229   4                  TR0     = 1 ;   //启动定时器0 
 230   4              T0Count = 0 ;   //定时器0计数值清零 
 231   4                } //KeyNum == 2
 232   3            if ( KeyNum == 3 ) 
 233   3            { 
 234   4              Mode = 3 ;    //程序切换到FFT高频模式(测量谐波)
 235   4              TR0     = 0 ;
 236   4              ADCS=0;
 237   4              AD7323(0X80);
 238   4              AD7323(0X30);
 239   4              ADCS=1;
C51 COMPILER V9.54   MAIN                                                                  04/11/2021 15:34:12 PAGE 5   

 240   4              TongDao=0;              
 241   4                  TH0    = (65536 - 33000000/2560 )/256 ;
 242   4                  TL0    = (65536 - 33000000/2560 )%256 ; //定时器0初值(1秒2560次中断0.4ms) 
 243   4                  TR0     = 1 ;
 244   4              T0Count = 0 ; 
 245   4            } //KeyNum == 3
 246   3            // //键码F1和F2屏幕显示内部数组,调试用
 247   3            // if ( KeyNum == 0xF1 ) {//显示FFT结果1
 248   3            //  for ( i = 0 ; i<200; i++ ) {
 249   3            //    GUI_ShowNum ( i%10*48 ,i/10*16,Fft_Real[i],5,16);}
 250   3            //  }//KeyNum == 0xF1
 251   3            // if ( KeyNum == 0xF2 ) {//显示FFT结果2
 252   3            //  for ( i = 0 ; i<200; i++ ) {
 253   3            //    GUI_ShowNum ( i%10*48 ,i/10*16,Fft_Image[i],5,16);}
 254   3            // } //KeyNum == 0xF2
 255   3          } //KeyFlag == 1
 256   2        } //while(1)
 257   1      }//
*** WARNING C280 IN LINE 102 OF main.c: 'VPP1': unreferenced local variable
*** WARNING C280 IN LINE 102 OF main.c: 'vrms1': unreferenced local variable
 258          
 259          
 260          void INTTIMER0 (void) interrupt 1 //定时器0中断
 261          { 
 262   1         u8   i ;
 263   1         OUT0  = 1 ;   //(1)中断开始时OUT置高,结束时置低,测试中断所需时间,调试用
 264   1        //(2)---利用SPI通讯,读取AD结果,并设置下次AD的参数
 265   1      
 266   1         ADCS  = 0 ;
 267   1         ADRes = AD7323(0x80) ;      
 268   1         ADRes = (ADRes*256 + AD7323(0x30))>>1;            //控制字:通道0对地,正常模式,二进制补码,同时读回通道0
 269   1         ADCS = 1 ; 
 270   1         //ADRes = AD7323(0x8030);
 271   1          //GUI_ShowNum (120,120,ADRes,10,16)
 272   1         if ( ADRes > 4095 ) {                          //因为0-8191对应-10V-+10V,所以要进行数制调整
 273   2            ADMul = (long int)(ADRes-4096)*(ADRes-4096)/32; //同时,计算AD结果的平方和,因为考虑到溢出,所以除了32
 274   2            ADRes = ADRes - 4096 ; } 
 275   1         else {
 276   2            ADMul = (long int)(4096-ADRes)*(4096-ADRes)/32 ;
 277   2            ADRes = ADRes - 4096 ; }
 278   1        //(3)如果是正弦波测量
 279   1         if ( Mode == 1 ) {   
 280   2            AD_Acc = AD_Acc + ADMul; //(3.1)平方和计算
 281   2            if (( ADOld < 16 ) && ( ADRes >= 16 )) { //(3.2)判断是否一个周期到了
 282   3              F_Count ++ ;           //(3.3)如果是,周期数加一
 283   3              if (OneSec)  {         //(3.4)如果一秒钟到了
 284   4                V_Acc = AD_Acc ; T_Acc = T0Count ; F_Acc = F_Count ; //记录结果
 285   4                AD_Acc = 0 ;     T0Count = 0 ;     F_Count= 0 ;
 286   4                MesOver = 1 ;OneSec = 0 ;  }
 287   3              }
 288   2            T0Count++;              //(3.5)定时器0计数值加一
 289   2            if ( T0Count == 4800 ) { OneSec = 1 ; } //(3.6)如果到4000次中断,表明一秒到了
 290   2            ADOld = ADRes ;         //(3.7)记录当前AD值
 291   2           }
 292   1        //(4)如果是Mode2和Mode3,进行AD结果放入数组中(LIST_TAB下标)
 293   1        //   采满1024点,设置标志位,准备计算
 294   1        if ( Mode == 2 )  {   //(2)如果是FFT低频测量
 295   2            if ( T0Count > 0 ) {
 296   3              Fft_Real[LIST_TAB[T0Count-1]] = ADRes ;
 297   3              Fft_Image[LIST_TAB[T0Count-1]] = 0 ;}
 298   2            T0Count ++ ;
 299   2            if (T0Count ==  1025 ) {
C51 COMPILER V9.54   MAIN                                                                  04/11/2021 15:34:12 PAGE 6   

 300   3              TR0 = 0 ; MesOver = 1 ; T0Count = 0 ; }
 301   2            } 
 302   1        if ( Mode == 3 )  {   //(3)如果是FFT高频测量
 303   2            if ( T0Count > 0 ) {
 304   3              Fft_Real[LIST_TAB[T0Count-1]] = ADRes ;
 305   3              Fft_Image[LIST_TAB[T0Count-1]] = 0 ;}
 306   2            T0Count ++ ;
 307   2            if (T0Count ==  1025 ) {
 308   3              TR0 = 0 ; MesOver = 1 ; T0Count = 0 ; }
 309   2            }       
 310   1          OUT0 = 0 ;
 311   1        }
*** WARNING C280 IN LINE 262 OF main.c: 'i': unreferenced local variable
 312            
 313          void INTUART1  (void) interrupt 4 //串口1中断
 314          {
 315   1         u8 DAT;
 316   1         if (RI) {
 317   2           RI = 0 ;
 318   2           DAT = SBUF ;
 319   2           SBUF = DAT ;
 320   2           }
 321   1         if (TI) {
 322   2           TI = 0 ;
 323   2           S1Num++ ;
 324   2           if ( S1Num < 6 ) 
 325   2              { SBUF = S1Send[S1Num] ;}
 326   2           else             
 327   2              { S1Num = 0 ; S1SendOver = 1;} 
 328   2           }
 329   1         }
 330          void INT3 ( void )  interrupt 11  //外部中断3--按键中断
 331          {
 332   1        KeyFlag = 1 ;
 333   1      }
 334          void   InterFace(void) //初始界面显示
 335          {
 336   1         FColor = RED ;
 337   1         DisP_Photo  (104,0,104+272-1,0+36-1,TITLE,0);  //显示单色图像
 338   1         FColor = BLACK;
 339   1         GUI_Rectangle(0, 36, 479, 319);//(4)画四边形
 340   1         GUI_Rectangle(2, 38, 477, 317);//
 341   1         FColor = DARKBLUE ;
 342   1         DisP_Photo  (120,40,120+240-1,40+36-1,CeLiang[2],0); //"请按键选择功能"
 343   1         }
 344          
 345          u8 AD7323(u8 CMD)
 346          {  u8  i ;
 347   1         u8 k=0x80,DataIn=0 ;
 348   1         SCK = 1 ;
 349   1         _nop_();_nop_();
 350   1         for (i=0 ; i<8 ; i++) {
 351   2           DataIn = DataIn <<1;
 352   2           if ( CMD & k ) { MOSI = 1 ; }
 353   2           else       { MOSI = 0 ; }
 354   2           SCK = 0 ;     _nop_();_nop_();_nop_();_nop_();_nop_();_nop_();
 355   2           SCK = 1 ;    
 356   2           if ( MISO ) { DataIn = DataIn|0x01 ;}
 357   2           k = k >>1;
 358   2           }
 359   1         return (DataIn) ;
 360   1         }
C51 COMPILER V9.54   MAIN                                                                  04/11/2021 15:34:12 PAGE 7   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2960    ----
   CONSTANT SIZE    =   8508    ----
   XDATA SIZE       =    154      13
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      6    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
